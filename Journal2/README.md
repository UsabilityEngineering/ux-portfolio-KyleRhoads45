# UX Journal 2 - The Future of Game Development

## Kyle Rhoads, 05/2/2021

Over the last decade the game development field has evolved rapidly thanks to the rise of free commercial game engines such as Unity, Unreal, and Godot. However, one thing that has remained the same over the years is the programming language that powers these high performant programs. The vast majority of game engines are written in C++ due to the language being mature and performant. However, there are a substantial amount of game developers who believe C++ is outdated but feels as though there are no good alternatives. Another popular language for game development is C#, which many people find enjoyable since it is a high-level language that abstracts away complex tasks and provides fantastic error detection. However, the disadvantages of C# are that it is a garbage collected language and is JIT (Just In Time) compiled, making it significantly slower than C++. An ideal language for game development would be a combination of the two languages, which is what Beef is attempting to do.

Beef is a new programming language that attempts to combine the performance of C++ with the usability of C#. Being a C# game developer myself, I have always been disappointed with the performance impact that comes with the language, which is why I was excited to try out Beef. In order to learn Beef, I decided to make a little 2D game using the language and its custom IDE. 

![alt text](/assets/BeefIDE.PNG)

The first time I ran the IDE I was pleasantly surprised with a sample project that showcased both language and IDE features. To prevent time wasting, the IDE comes with SDL2 bindings, which provides a lot of functionalities that are essential to games such as graphics, sound, and keyboard input. There were also comments in the main file that provided instructions to discover IDE features such as memory leak detection, error handling, and hot reloading. All of which help contribute to the **learnability** (how easy something is to learn) of the code editor. In addition, there was a sample game written by the developer of the language which also contributes to making it **learnable**, since it introduces the syntax of the language and its unique statements. When it came to writing my own Beef game, I often referenced the sample game code when I had syntax errors or was unsure how to use a SDL2 function. Overall, the language was very **learnable** because of the sample code and tools provided, but there is still room for improvement. 

One aspect that affected the **learnability** of the language is the documentation on the website. The documentation does a good job at explaining basic language features but fails to cover more advanced topics. This became a problem when I found a confusing statement in the sample code and was unable to **learn** what it does since it was not in the documentation. Which brings up another issue that hurts the learnability of the language, which is that there are no third-party resources available. When I came across the statement "**list(sound) = new .() ~delete _;**" and conducted a Google search, nothing of relevance came up. This makes Beef much more difficult to learn because if there is no explanation in the official documentation, then the explanation does not exist. 

Overall, I did enjoy the time I spent using Beef and its tools. I was able to make a little 2D game with it while getting a feel for the language. Although I still have confusions about the language due to the lack of documentation, I was able to find workarounds in order to complete my game.
